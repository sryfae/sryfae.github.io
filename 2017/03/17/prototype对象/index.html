
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>prototype对象 | sry blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="sry">
    
    <meta name="description" content="概述构造函数的缺点JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。
但是同一个构造函数的对象实例之间，无法共享属性。
下面代码中，cat1和cat2是同一个构造函数的实例。但是，它们的meow方法是不一样的，就是说每新建一个实">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="sry blog" title="sry blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="sry blog">sry blog</a></h1>
				<h2 class="blog-motto">前端小白的学习之路</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归类</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:sryria.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/17/prototype对象/" title="prototype对象" itemprop="url">prototype对象</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://sryria.com" title="sry">sry</a>
    </p>
  <p class="article-time">
    <time datetime="2017-03-17T02:21:02.000Z" itemprop="datePublished">2017-03-17</time>
    更新日期:<time datetime="2017-03-17T08:45:27.197Z" itemprop="dateModified">2017-03-17</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的缺点"><span class="toc-number">1.1.</span> <span class="toc-text">构造函数的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype属性的作用"><span class="toc-number">1.2.</span> <span class="toc-text">prototype属性的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链"><span class="toc-number">1.3.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor属性"><span class="toc-number">1.4.</span> <span class="toc-text">constructor属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof运算符"><span class="toc-number">2.</span> <span class="toc-text">instanceof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-number">3.</span> <span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-number">4.</span> <span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create"><span class="toc-number">5.</span> <span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-isPrototypeOf"><span class="toc-number">6.</span> <span class="toc-text">Object.prototype.isPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-proto"><span class="toc-number">7.</span> <span class="toc-text">Object.prototype.proto</span></a></li></ol>
		</div>
		
		<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>
<p>但是同一个构造函数的对象实例之间，无法共享属性。</p>
<p>下面代码中，cat1和cat2是同一个构造函数的实例。但是，它们的meow方法是不一样的，就是说每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name, color) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">  this.meow = function () &#123;</span><br><span class="line">    console.log(&apos;mew, mew, mew...&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);</span><br><span class="line">var cat2 = new Cat(&apos;二毛&apos;, &apos;黑色&apos;);</span><br><span class="line">cat1.meow === cat2.meow</span><br><span class="line">// false</span><br></pre></td></tr></table></figure>
<h3 id="prototype属性的作用"><a href="#prototype属性的作用" class="headerlink" title="prototype属性的作用"></a>prototype属性的作用</h3><p>JavaScript的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。</p>
<p>原型对象上的所有属性和方法，都能被派生对象共享。这就是JavaScript继承机制的基本设计。</p>
<p>通过构造函数生成实例对象时，会自动为实例对象分配原型对象。每一个构造函数都有一个prototype属性，这个属性就是实例对象的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Animal (name) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color = &apos;white&apos;;</span><br><span class="line">var cat1 = new Animal(&apos;大毛&apos;);</span><br><span class="line">var cat2 = new Animal(&apos;二毛&apos;);</span><br><span class="line">cat1.color // &apos;white&apos;</span><br><span class="line">cat2.color // &apos;white&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。结果，实例对象都能读取该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.color = &apos;yellow&apos;;</span><br><span class="line"></span><br><span class="line">cat1.color // &quot;yellow&quot;</span><br><span class="line">cat2.color // &quot;yellow&quot;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。</p>
<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat1.color = &apos;black&apos;;</span><br><span class="line"></span><br><span class="line">cat2.color // &apos;yellow&apos;</span><br><span class="line">Animal.prototype.color // &quot;yellow&quot;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，实例对象cat1的color属性改为black，就使得它不再去原型对象读取color属性，后者的值依然为yellow。</p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的含义，而实例对象可以视作从原型对象衍生出来的子对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.walk = function () &#123;</span><br><span class="line">  console.log(this.name + &apos; is walking&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Animal.prototype对象上面定义了一个walk方法，这个方法将可以在所有Animal实例对象上面调用。</p>
<p>由于JavaScript的所有对象都有构造函数，而所有构造函数都有prototype属性（其实是所有函数都有prototype属性），所以所有对象都有自己的原型对象。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。那么，Object.prototype对象有没有它的原型呢？回答可以是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">// null</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。</p>
<p>“原型链”的作用是，读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。</p>
<p>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overiding）。</p>
<p>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var MyArray = function () &#123;&#125;;</span><br><span class="line">MyArray.prototype = new Array();</span><br><span class="line">MyArray.prototype.constructor = MyArray;</span><br><span class="line">var mine = new MyArray();</span><br><span class="line">mine.push(1, 2, 3);</span><br><span class="line">mine.length // 3</span><br><span class="line">mine instanceof Array // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，mine是构造函数MyArray的实例对象，由于MyArray的prototype属性指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。至于最后那行instanceof表达式，我们知道instanceof运算符用来比较一个对象是否为某个构造函数的实例，最后一行就表示mine为Array的实例。</p>
<p>下面的代码可以找出，某个属性到底是原型链上哪个对象自身的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getDefiningObject(obj, propKey) &#123;</span><br><span class="line">  while (obj &amp;&amp; !&#123;&#125;.hasOwnProperty.call(obj, propKey)) &#123;</span><br><span class="line">    obj = Object.getPrototypeOf(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><p>prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function P() &#123;&#125;</span><br><span class="line"></span><br><span class="line">P.prototype.constructor === P</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<p>由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function P() &#123;&#125;</span><br><span class="line">var p = new P();</span><br><span class="line">p.constructor</span><br><span class="line">// function P() &#123;&#125;</span><br><span class="line">p.constructor === P.prototype.constructor</span><br><span class="line">// true</span><br><span class="line">p.hasOwnProperty(&apos;constructor&apos;)</span><br><span class="line">// false</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，p是构造函数P的实例对象，但是p自身没有contructor属性，该属性其实是读取原型链上面的P.prototype.constructor属性。</p>
<p>constructor属性的作用，是分辨原型对象到底属于哪个构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function F() &#123;&#125;;</span><br><span class="line">var f = new F();</span><br><span class="line">f.constructor === F // true</span><br><span class="line">f.constructor === RegExp // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，使用constructor属性，确定实例对象f的构造函数是F，而不是RegExp。</p>
<p>有了constructor属性，就可以从实例新建另一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Constr() &#123;&#125;</span><br><span class="line">var x = new Constr();</span><br><span class="line">var y = new x.constructor();</span><br><span class="line">y instanceof Constr // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，x是构造函数Constr的实例，可以从x.constructor间接调用构造函数。</p>
<p>这使得在实例方法中，调用自身的构造函数成为可能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constr.prototype.createCopy = function () &#123;</span><br><span class="line">  return new this.constructor();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这也提供了继承模式的一种实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;&#125;</span><br><span class="line">function Sub() &#123;</span><br><span class="line">  Sub.superclass.constructor.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Sub.superclass = new Super();</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Super和Sub都是构造函数，在Sub内部的this上调用Super，就会形成Sub继承Super的效果。</p>
<p>由于constructor属性是一种原型对象与构造函数的关联关系，所以修改原型对象的时候，务必要小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">a instanceof A // true</span><br><span class="line"></span><br><span class="line">function B() &#123;&#125;</span><br><span class="line">A.prototype = B.prototype;</span><br><span class="line">a instanceof A // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，a是A的实例。修改了A.prototype以后，constructor属性的指向就变了，导致instanceof运算符失真。</p>
<p>所以，修改原型对象时，一般要同时校正constructor属性的指向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 避免这种写法</span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">// 较好的写法</span><br><span class="line">C.prototype = &#123;</span><br><span class="line">  constructor: C,</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">// 好的写法</span><br><span class="line">C.prototype.method1 = function (...) &#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，避免完全覆盖掉原来的prototype属性，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。</p>
<p>此外，通过name属性，可以从实例得到构造函数的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">var f = new Foo();</span><br><span class="line">f.constructor.name // &quot;Foo&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h2><p>instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v = new Vehicle();</span><br><span class="line">v instanceof Vehicle // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象v是构造函数Vehicle的实例，所以返回true。</p>
<p>instanceof运算符的左边是实例对象，右边是构造函数。它的运算实质是检查右边构建函数的原型对象，是否在左边对象的原型链上。因此，下面两种写法是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v instanceof Vehicle</span><br><span class="line">// 等同于</span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure></p>
<p>由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">d instanceof Date // true</span><br><span class="line">d instanceof Object // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，d同时是Date和Object的实例，因此对这两个构造函数都返回true。</p>
<p>instanceof的原理是检查原型链，对于那些不存在原型链的对象，就无法判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.create(null) instanceof Object // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Object.create(null)返回的新对象的原型是null，即不存在原型，因此instanceof就认为该对象不是Object的实例。</p>
<p>除了上面这种继承null的特殊情况，JavaScript之中，只要是对象，就有对应的构造函数。因此，instanceof运算符的一个用处，是判断值的类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x = [1, 2, 3];</span><br><span class="line">var y = &#123;&#125;;</span><br><span class="line">x instanceof Array // true</span><br><span class="line">y instanceof Object // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，instanceof运算符判断，变量x是数组，变量y是对象。</p>
<p><strong><em><mark>注意，instanceof运算符只能用于对象，不适用原始类型的值。</mark></em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line">s instanceof String // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串不是String对象的实例（因为字符串不是对象），所以返回false。</p>
<p>此外，undefined和null不是对象，所以instanceOf运算符总是返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined instanceof Object // false</span><br><span class="line">null instanceof Object // false</span><br></pre></td></tr></table></figure></p>
<p>利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Fubar (foo, bar) &#123;</span><br><span class="line">  if (this instanceof Fubar) &#123;</span><br><span class="line">    this._foo = foo;</span><br><span class="line">    this._bar = bar;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    return new Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 空对象的原型是Object.prototype</span><br><span class="line">Object.getPrototypeOf(&#123;&#125;) === Object.prototype</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">// 函数的原型是Function.prototype</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">Object.getPrototypeOf(f) === Function.prototype</span><br><span class="line">// true</span><br><span class="line"></span><br><span class="line">// f 为 F 的实例对象，则 f 的原型是 F.prototype</span><br><span class="line">var f = new F();</span><br><span class="line">Object.getPrototypeOf(f) === F.prototype</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p>
<h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p>Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;x: 1&#125;;</span><br><span class="line">var b = Object.setPrototypeOf(&#123;&#125;, a);</span><br><span class="line">// 等同于</span><br><span class="line">// var b = &#123;__proto__: a&#125;;</span><br><span class="line"></span><br><span class="line">b.x // 1</span><br></pre></td></tr></table></figure>
<p>上面代码中，b对象是Object.setPrototypeOf方法返回的一个新对象。该对象本身为空、原型为a对象，所以b对象可以拿到a对象的所有属性和方法。b对象本身并没有x属性，但是JavaScript引擎找到它的原型对象a，然后读取a的x属性。</p>
<p>new命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的prototype属性，然后在实例对象上执行构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var F = function () &#123;</span><br><span class="line">  this.foo = &apos;bar&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">var f = new F();</span><br><span class="line">// 等同于</span><br><span class="line">var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);</span><br><span class="line">F.call(f);</span><br></pre></td></tr></table></figure></p>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>Object.create方法用于从原型对象生成新的实例对象，可以替代new命令。</p>
<p>它接受一个对象作为参数，返回一个新对象，后者完全继承前者的属性，即原有对象成为新对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;</span><br><span class="line"> print: function () &#123;</span><br><span class="line">   console.log(&apos;hello&apos;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B = Object.create(A);</span><br><span class="line"></span><br><span class="line">B.print() // hello</span><br><span class="line">B.print === A.print // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，Object.create方法在A的基础上生成了B。此时，A就成了B的原型，B就继承了A的所有属性和方法。</p>
<p>实际上，Object.create方法可以用下面的代码代替。如果老式浏览器不支持Object.create方法，可以就用这段代码自己部署。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.create !== &apos;function&apos;) &#123;</span><br><span class="line">  Object.create = function (o) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，Object.create方法实质是新建一个构造函数F，然后让F的prototype属性指向作为原型的对象o，最后返回一个F的实例，从而实现让实例继承o的属性。</p>
<p>下面三种方式生成的新对象是等价的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o1 = Object.create(&#123;&#125;);</span><br><span class="line">var o2 = Object.create(Object.prototype);</span><br><span class="line">var o3 = new Object();</span><br></pre></td></tr></table></figure></p>
<p>如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var o = Object.create(null);</span><br><span class="line">o.valueOf()</span><br><span class="line">// TypeError: Object [object Object] has no method &apos;valueOf&apos;</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，如果对象o的原型是null，它就不具备一些定义在Object.prototype对象上面的属性，比如valueOf方法。</p>
<p>使用Object.create方法的时候，必须提供对象原型，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.create()</span><br><span class="line">// TypeError: Object prototype may only be an Object or null</span><br></pre></td></tr></table></figure></p>
<p>Object.create方法生成的对象，继承了它的原型对象的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">var b = Object.create(a);</span><br><span class="line">b.constructor === A // true</span><br><span class="line">b instanceof A // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，b对象的原型是a对象，因此继承了a对象的构造函数A。</p>
<h2 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h2><p>对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;&#125;;</span><br><span class="line">var o2 = Object.create(o1);</span><br><span class="line">var o3 = Object.create(o2);</span><br><span class="line">o2.isPrototypeOf(o3) // true</span><br><span class="line">o1.isPrototypeOf(o3) // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码表明，只要某个对象处在原型链上，isPrototypeOf都返回true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.isPrototypeOf(&#123;&#125;) // true</span><br><span class="line">Object.prototype.isPrototypeOf([]) // true</span><br><span class="line">Object.prototype.isPrototypeOf(/xyz/) // true</span><br><span class="line">Object.prototype.isPrototypeOf(Object.create(null)) // false</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，由于Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。</p>
<h2 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.proto"></a>Object.prototype.<strong>proto</strong></h2><p><strong>proto</strong>属性（前后各两个下划线）可以改写某个对象的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var p = &#123;&#125;;</span><br><span class="line">obj.__proto__ = p;</span><br><span class="line">Object.getPrototypeOf(obj) === p // true</span><br></pre></td></tr></table></figure></p>
<p>上面代码通过<strong>proto</strong>属性，将p对象设为obj对象的原型。</p>
<p>根据语言标准，<strong>proto</strong>属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。</p>
<p>原型链可以用<strong>proto</strong>很直观地表示。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/面向对象编程/">面向对象编程</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://sryria.com/2017/03/17/prototype对象/" data-title="prototype对象 | sry blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2017/03/16/this关键字/"  title="this关键字">
 <strong>NEXT:</strong><br/> 
 <span>this关键字
</span>
</a>
</div>

</nav>

	
<section class="youyan" id="comments" style="margin: 3em 3em 0 3em">
  <div id="uyan_frame"></div>
  <script src="http://v2.uyan.cc/code/uyan.js?uid=2128409"></script>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的缺点"><span class="toc-number">1.1.</span> <span class="toc-text">构造函数的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype属性的作用"><span class="toc-number">1.2.</span> <span class="toc-text">prototype属性的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链"><span class="toc-number">1.3.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor属性"><span class="toc-number">1.4.</span> <span class="toc-text">constructor属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof运算符"><span class="toc-number">2.</span> <span class="toc-text">instanceof运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-number">3.</span> <span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-number">4.</span> <span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create"><span class="toc-number">5.</span> <span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-isPrototypeOf"><span class="toc-number">6.</span> <span class="toc-text">Object.prototype.isPrototypeOf()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype-proto"><span class="toc-number">7.</span> <span class="toc-text">Object.prototype.proto</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/HTML5/" title="HTML5">HTML5<sup>2</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>2</sup></a></li>
		
			<li><a href="/tags/bandit-CF/" title="bandit&amp;CF">bandit&amp;CF<sup>3</sup></a></li>
		
			<li><a href="/tags/前端安全/" title="前端安全">前端安全<sup>1</sup></a></li>
		
			<li><a href="/tags/协同过滤算法学习/" title="协同过滤算法学习">协同过滤算法学习<sup>2</sup></a></li>
		
			<li><a href="/tags/网络/" title="网络">网络<sup>1</sup></a></li>
		
			<li><a href="/tags/面向对象编程/" title="面向对象编程">面向对象编程<sup>3</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/2495479173" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/sryfae" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2017 
		
		<a href="http://sryria.com" target="_blank" title="sry">sry</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



  </body>
</html>
